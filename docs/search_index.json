[
["index.html", "Mobile forms for salmon surveys Welcome", " Mobile forms for salmon surveys Are Strom Welcome The growing popularity of mobile technology for data collection has increased both the types of data, and the volume of data, flowing from field to database. The advantages of mobile devices over paper forms are compelling. Mobile devices enable automated data capture using a wide assortment of sensors, including temperature probes, pH meters, barcode readers, cameras, PIT tag readers, and integrated GPS. In the past, data from a complete spawning ground survey would typically have been entered first in a field notebook, then transcribed to a 3x5 index card, and finally entered to an electronic spreadsheet. The electronic portion would rarely require more than a few kilobytes of memory. By contrast, mobile technology enables capturing a much richer set of data, possibly including binary data such as images or video. Consequently, storage requirements can grow to megabyte size and manual transcription is no longer practical. This, in turn, requires better systems to store, retrieve, and analyze an expanding flow of data. Making sure that data systems are well integrated is becoming increasingly important. At the Washington Department of Fish and Wildlife (WDFW), a new spawning ground database has been constructed to absorb the increased flow, and diversity, of data on the back-end. Integration on the front-end is still a work in progress. This manual was motivated by the need for guidelines and standards at the mobile device end. The aim is two-fold: first, to provide simple examples to assist those just learning to build mobile forms, and second, to document data input elements needed to facilitate getting data securely moved from field to database. Building mobile forms can be a source of frustration, even for experienced IT staff. Although it is true that simple forms can be built quickly and easily, even moderately complex forms, such as those typically needed for spawning ground surveys, require a considerable amount of work. Once you start adding conditional logic and validation to your forms you will need to write some code. A formalized set of guidelines, along with step-by-step instructions, can help ease the pain. Standardizing the general structure of mobile forms can also help enable a smooth flow of data from field to back-end database. Although survey protocols vary from region to region, in general, they are similar enough that there is much to be gained from copying what works and learning from each other. To simplify the process of building mobile forms this manual takes a highly opinionated approach. As you gain experience in form building, feel free to customize as needed. But please keep in mind that core input elements need to be present in order to enable downloading and processing data so it can be integrated into our corporate spawning ground database. These core input elements will be emphasized in the sections that follow. Please consider contributing your own solutions, corrections, or edits to this manual. All source code is available at the project GitHub repository. It is written using the bookdown package. See bookdown: Authoring Books and Technical Documents with R Markdown for technical details on how to contribute. Thanks to James Losee for the cover photo. "],
["intro.html", "1 Introduction 1.1 Why mobile forms? 1.2 API 1.3 Profiles 1.4 Useful tips 1.5 Conventions", " 1 Introduction The WDFW Fish Program currently uses iFormBuilder as a platform for building and deploying mobile forms. Although there are numerous alternative mobile platforms, both commercial and open-source, among the benefits of iFormBuilder are an easy-to-use form building application, a fairly good system for syncing between forms and devices, and an excellent application programming interface (API). The API is particulary useful, as it allows us to automate many of the most burdensome aspects of building forms and managing data flows. 1.1 Why mobile forms? 1.1.1 Trade-offs Mobile electronic forms provide a number of advantages over paper forms, but as always, there are trade-offs. For seasoned surveyors, the field notebook has long proven to be a simple and effective tool to jot down observations. Short-hand comments and codes have been developed that enable recording a great deal of information succinctly and quickly. Switching to mobile forms can slow down data entry in the field, at least initially. This can be frustrating when you have a large number of streams to survey, limited staff, or short windows of opportunity between fall and winter storms to get those surveys completed. Avoiding unnecessary slowdowns and keeping your surveyors happy is important. This is also the main reason for making sure the structure of mobile forms is kept as simple as possible. Minimizing the number of subforms can speed up data entry in the field. Conditionally hiding data inputs until they are truly needed keep forms streamlined and free of unneeded clutter. But regardless of how simple the form, there will still be some pain to begin with. That pain will go away in time, especially as the benefits of using mobile forms become more apparent. If your survey protocols are relatively simple, and you are only interested in recording a few core data elements, the benefits of mobile survey forms may not be immediately apparent. In such cases the entire process of capturing, recording, transcribing, proofing, analyzing data may need to be taken into account before the true efficiencies become compelling. 1.1.2 Automated, integrated, data capture Mobile forms allow capturing data using a variety of sensors quickly and accurately. Those data are then fully integrated with all your other observations. A good example is location data. It can often be useful to map locations of salmon redds to understand density over time, or see how changes in habitat have affected populations in a particular section of a creek or river. Using a typical combination of field notebook and a separate GPS unit, considerable work is required to download, proof, and integrate the location data with the field notebook data. Both the field notebook data and GPS data needs to be separately entered, proofed, and finally combined. Mobile devices include integrated GPS, and output integrated data. There is no need for manually combining disparate sets of data after the survey. 1.1.3 Enter once Mobile forms avoid the need to transcribe data from a field notebook or write-in-the-rain datasheets to electronic format. Data only needs to be entered once. This avoids common transcription errors that can often be notoriously hard to spot. After the Done button has been clicked on the mobile device, the data can then be automatically written to our corporate database with no additional effort on the part of the surveyor or supervisor. After the data has been written to the central database it can be inspected, edited if needed, and exported for reports or analysis. 1.1.4 Validation Another advantage of mobile forms is data integrity. Common errors can be automatically detected while still in the field by adding validation code directly into your forms. An unusual value can be flagged and the surveyor immediately asked to verify the suspect value before submitting. Validation code can be as simple or elaborate as needed. It is normal to add additional validation code after you launch a mobile form and you start to notice where errors tend to occur. An especially useful feature of mobile forms is that you can add validation or other features as you progress through the season. There is no need to print new survey forms. Updates to your form will be automatically synced to mobile devices every time the form is opened. 1.1.5 Reporting For biologists, an added bonus of mobile forms is a clean set of data that is housed in a predictable format, and securely backed up. With proper validation on the front-end, data transmitted from mobile form to back-end database is immediately available for reporting and analysis. Clean data, organized in a consistent format can make it easier to produce population estimates and reports. Data requests can typically be handled with a few mouse-clicks to export the relevant data. 1.2 API As mentioned earlier, a major benefit of using the iFormBuilder platform for building and deploying mobile forms is the application programming interface, or API. An API is simply a set of protocols that allows computers to talk to one another. One case where the API can avoid a great deal of pain is in constructing large filtered option lists. The prime example for spawning ground surveys are the drop-down pick-lists for survey start and stop points along a given stream. Lists with thousands of elements can be constructed and uploaded to the iFormBuilder cloud in seconds. The iformr package provides a set of functions that allows for using R scripts to automate many of these types of tasks. Instructions for how to get started can be found in package GitHub repository. 1.3 Profiles Since the source code for this manual is hosted on a public website, I will not go into detail on setting up devices, assigning AppleIDs, Google Play store accounts, or connecting to the WDFW iFormBuider account. The only prerequiste that needs to be stressed here is that you will want to get a separate iFormBuilder Profile set up for your workgroup. The main benefit is that it keeps your forms and option lists segregated from other groups, and makes it less likely you will lose data because someone accidentally edited your formâ€¦or deleted an option list. Contact me if you need help to get this set up. 1.4 Useful tips 1.4.1 Searching for help There is a great deal of information available at the iFormBuilder website for learning how to build forms. This includes an extensive list of videos. Unfortunately, that information is not always well organized. You can often get better results doing your own internet search and prefacing a general search term such as parse location with iformbuilder, rather than using iFormBuilderâ€™s help pages. That said, the Customer Success Center is still a good place to start. If you have not already done so, watch the Art of Form Building video for an introduction to best practices. You can also use the iFormBuilder chat feature that typically pops up in the lower right-hand side of your screen when you open the Customer Success Center. This tends to be the quickest way to get answers to specific questions. At some point you will need to write simple JavaScript code. This is especially important when you want to create conditional logic to hide or show a data input, validate data, or sum up a set of counts. My favorite site for help with JavaScript is w3schools. If you need to do something more complex, you will usually find that someone has already written a function to accomplish exactly what you want. Try searching on stackoverflow. In addition, there is a selection of commonly used JavaScript functions located in the appendix section of this manual. 1.4.2 Data column names When adding new data inputs to your form keep in mind that the data_column names must be what is termed database friendly. They must all be in lower case, and you cannot use compound words, such as redd count without first tying the words together using an underscore. For example, redd_count. There is also a long list of reserved words that you cannot use for data_column names. The complete list can be downloaded from the link above. 1.4.3 Option lists Always remember that option lists can be shared among different forms. This means that whenever you edit an option lists you are editing options for all forms that share the list. This can cause major problems, including data loss, if you have other mobile forms in your profile and those forms share option lists. 1.4.4 Save often When building forms, remember to Save frequently. Best practice is to get into the habit of clicking the save icon in the upper right-hand corner of the form builder interface every time you make a change. Few things are more annoying than to make a series of changes to a form, then later realize that all your work has dissapeared because you forgot to save. 1.5 Conventions This manual is meant to be an interactive resource for those learning to build mobile forms using the iFormBuilder platform. As such, there are numerous links to outside resources included. These are highlighted in blue. For example: w3schools. You will also find snippets of code that can be copied and pasted directly from this manual to your forms. These are entered to code blocks such as: if(species == 3 &amp;&amp; redd_status == 0) {&quot;Yes&quot;} else {&quot;No&quot;} Code blocks are also used to highlight text, code, or numbers that you enter directly into the form builder web application when designing forms. For example: ZCDisplayValue_stream, or the number -1, or data column names such as survey_method. Screenshots are liberally included to help identify where commands are located in the form builder application. Bold text is used to bring attention to items of particular importance, such as Save often. Finally, suggestions are always welcome on how to improve this manual. If you find errors, discover cases where conventions are not followed, locate additional outside resources that should be linked, or identify places where additional screenshots would be helpful, please let me know. You can file issues or contribute your suggestions at the project GitHub repository. "],
["get-started.html", "2 Get started 2.1 Import example form 2.2 A brief tour: Parent form 2.3 A brief tour: Observations subform 2.4 Additional options", " 2 Get started The aim of this chapter is to provide a visual tour of what a spawning ground form built using the iFormBuilder platform could look like. The first section describes how to load an example spawning ground survey form to your profile. Then the following sections provide a guided tour of the parent header form and the observations subform. The focus is on design elements, and what is visible to the surveyor on the device. Technical details on how to build forms will be addressed in chapter 3. 2.1 Import example form The quickest way to get started with mobile forms is by example. Download the Package_spawning_ground.json file from the GitHub repository for this manual. To download, click on the Package_spawning_ground.json link. You will see a list of files in the repository directory. Locate the Package_spawning_ground.json file in repository list and then click on the file. This will open a new window and display the contents of the file. Click on the *Raw&quot; button in the upper right-hand corner. This will fill your display with the raw contents of the file. You can now right-click anywhere in your display and save the contents to a convenient location on your computer. In the Save As dialog the default name for the file will be Package_spawning_ground.json.txt. Accept the default and click Save. Then navigate to the location where you saved the file and edit the name to remove the .txt part. Windows will warn you not to do this, but do it anyway. You should end up with a file name of Package_spawning_ground.json. Sign in to your iFormBuilder profile and click on the Forms tab, then click on Form Packages &gt; Package Import. In the Package Importer screen, click Choose File, navigate to where you downloaded the Package_spawning_ground.json file, and click Import. If you have existing forms in your profile make sure and select the Keep Both options in the Conflict Mode screen. After you have imported the form click on the Forms tab, then Form Assignment. You should see two new forms: spawning_ground_p and spawning_ground_s. The trailing p indicates the parent form. The trailing s indicates the subform. Highlight the row for spawning_ground_s then click Assign in the upper left corner. Uncheck the boxes for Collect and View. Then scroll to the bottom and click Update. You should never have anything but the parent form assigned to users. Open the iFormBuilder application on your mobile device. If you have done the preceeding steps correctly you should now see a form called Spawning Ground Surveys in the iFormBuilder application on your device. 2.2 A brief tour: Parent form The parent form is where you would record information that only needs to be entered once per survey. This is typically the header information you would see at the top of a paper form. Any repeating lines of data (individual observations) will be entered to a subform. The sections below assume that you have a device loaded with the example Spawning Ground form. If not, please do so now. 2.2.1 Hiding questions After you have synced the Spawning Ground form to your device, click to launch. You should see a fairly bare form. The only items showing will be some basic header information. Items include a multiselect dropdown widget for Observers, a set of select buttons for Data entry real-time or post-survey, a Survey start date &amp; time widget, a set of Survey method select buttons, a dropdown widget for Stream, and a Done button. The reason that you only see a few input elements at first is that we have hidden the others using conditional logic. Hidden inputs will only be revealed after prerequisite fields have been filled out. Selectively hiding input elements in a form is a highly effective tool for reducing clutter and simplifying form structure. 2.2.2 Required fields Note the asterisks next to the labels for each input element. This indicates required fields. If you fail to fill any of these out you will be reminded when you hit the Done button. You will not be allowed to save or submit your data until all required fields are filled in. 2.2.3 Real-time or post-survey The Data entry real-time or post-survey field illustrates how you can set up rules to show or hide input elements in your form based on an initial conditions. For example, if you have some old paper data to enter and you need to use the mobile form as a post-survey data entry screen, then we know we donâ€™t need to show widgets for recording GPS locations at a later stage. In addition, we probably wonâ€™t need to show widgets for capturing barcodes, or taking pictures. These can all be hidden if the data entry type is set to Post-survey. 2.2.4 Default values Notice that for the Data entry real-time or post-survey and Survey method inputs we have pre-selected default values of Real-time and Foot respectively. For Survey start date &amp; time we can set a default value of the current date and time by using a JavaScript function new Date(). Setting default values is a good way to help speed up data entry in the field. Details on how to set this up is included in Chapter 3. 2.2.5 Filtered option lists The Stream, Survey start point and Survey end point input elements demonstrate use of filtered option lists. Click on Stream and you will see a list of stream names. Start and stop points for stream reach sections that are typically surveyed are displayed. These are filtered to the stream you select. If you change the Stream selection, a different set of start and stop points options will be displayed. Select Bear Cr (19.0196) to see a good example of using labels to help identify filtered options. If you now click on the Survey start point pick list you will see a simple set of descriptions for the filtered points. At the bottom of each option list for start and stop points you have the ability to enter Not listed above. If you select this option two additional form input elements will appear where you can enter the approximate river mile of the location and a description of the location. Ideally, all reach end points that you normally survey will already be entered to your option lists. New points can easily be added, even to a live form, but for those rare cases where the unexpected happens, it is sometimes a good idea to provide options for manual entry. Keep this to a minimum though, as it can quickly make a form overly complex and unwieldy. 2.2.6 Data validation For an example of data validation, click on the Water temperature (degree C) widget and enter the number 45, then click the Done button. You should see a message pop-up that says The start point water temperature must be between 0 and 38 degrees Celsius. These types of validations are simple to set up. Details will be provided in Chapter 3. 2.2.7 Automated entry of zero counts The Target species multiselect widget is intended as an automated way to enter zero counts. For example, if your survey is specifically targeted for Coho and Chinook, and your survey will be used to calculate population estimates, entering zero counts is crucial. By entering Coho and Chinook as target species, a zero count can automatically be entered on the backend for these species. The alternative would be to manually enter a count of zero for each species targeted. Automating the process of entering zero counts can help speed up data entry in the field. The follow-up question below asks you to specify the categories of counts where zeros should be entered. Depending on the type of survey, this question allows you to specify if zero counts should be entered for fish counts, redds counts, or both. If you are strictly conducting a redd survey you would only want zeros entered for redds. If you are only doing a carcass survey, you will want to specify Fish only. If you are conducting a complete survey, including redd, live, and carcass counts, you will want zero counts entered for Both fish and redds. 2.2.8 Toggling a subform The final header data question in the top section asks Did you see any fish or fish redds?. If you answer Yes a subform will become visible where you can enter each observation. If you answer No you will only need to fill in a few remaining post-survey questions. To complete the questions on the parent form click No to this question. 2.2.9 Survey comments and dynamic labels In the bottom portion of the parent form you are asked to enter some canned pick-list comments regarding Stream flow, Visibility conditions, and Weather. The new spawning ground database provides many additional options for canned comments adapted from legacy condition codes that you may have used in the past. See the spawning_ground database Data Dictionary for a full list of these comments. Click on Survey_comment in the navigation panel on the left-hand side to see the comments currently available. Comment descriptions are listed in the look-up tables linked to the survey_comment table. You are next asked if the survey was completed. If not, then you are asked to explain why. Toggle between answering Completed survey and any other option. Notice that the label for the Survey comments field will change from (optional) to (required). In addition, a note will appear reminding you that an explantion is needed. This is a good example of using Dynamic lables. Additional details will be provided in Chapter 3. 2.2.10 Setting optional fields to required The final two questions allow you to enter general comments on the survey, and the time the survey was finished. Both questions are technically set as optional, but remember that you will still need to enter an explanation if you did not answer Completed survey above. This demonstrates how optional fields can conditionally be set to required, without explicitly toggling the Required setting when building the form. 2.3 A brief tour: Observations subform Go back to the question Did you see any fish or fish redds? and click Yes. The Observation subform will be displayed. Click on the Observation subform to allow entering counts of fish, redds and any ancillary information. After opening the subform you will need to specify if the Observation type was for live fish, dead fish, or redds. Depending on your answers a different set of questions will be displayed. After you enter Observation type and Species toggle between Fish redd and the other two options in Observation type to see how the questions near the bottom of the screen vary. The initial set of questions after selecting Observation type and Species will be identical. They will ask about Run year, and Survey type. Each of these are core questions that are required in the form, and must be anwered in order to enter the data to our corporate database. In our example, Run year is set to the current year. You could also use JavaScript to auto-generate different values depending on species and current date. Or you can manually edit Run year as needed. Survey type can vary depending on species and survey protocol. This is why survey type is included at the subform level. For example, during a fall Chinook index survey, Pink salmon encounters may need to be entered as supplemental. Note that depending on the species selected, the text for subsequent questions will be altered to include the species name. This is another example of Dynamic labels. 2.3.1 Live fish Go back to Observation type and select Live fish, then select Chinook as Species. A relatively simple set of form inputs will be displayed. After you enter a count of how many fish you saw you will see options to enter the location, along with Sex and maturity and Adipose clip status. Enter some arbitrary values for these fields and click the Done button. As soon as the form saves the record it will cycle right back to the start of the Observation subform and you can enter the next observation. The ability of the subform to cycle back to the start after saving a record is a feature you can specify when designing the form. It is called SUBFORM_BATCH_MODE. Details will be provided in Chapter 3. Notice also that the form is sticky in the sense that after you press the Done button, it remembers the Species and Survey type you entered last, and initiates the new observation with the values you used most recently. This stickiness can be useful if you typically encounter the same species repeatedly during a survey. Chapter 3 will detail how to code this behavior in the dynamic value box of a field. Change the Species to Pink and notice that the option to enter Adipose clip status dissapears. Using conditional logic you can first make a list of the species likely to have clipped fins, and then only display the Adipose clip status question when one of those species is encountered. 2.3.2 Carcass Click the Done button and cycle back to the top of the subform to enter a new observation. This time select Carcass as the Observation type and Chinook as the Species. The initial set of questions will look the same as for live fish. But if you enter a count of 2 or more for the Number of Chinook counted you will see a note reminding you that you must enter a count of 1 if you also want to enter additional biological data that is typically associated with individual fish, such as spawn condition, length measurements, or scale samples. This forces data for individual fish to be entered one fish at a time to our corporate database. If otoliths, or tissue samples for DNA analaysis are taken, the form will also assign a unique ID (UUID) that allows a single fish to be tracked in our data systems as a unique entity. If you now edit the Number of Chinook counted and enter 1, you will see a question appear asking: Did you take a sample?. If you select either Otolith or Tissue a UUID will be generated in a hidden field. You are also given the option to manually enter a Sample number. This will be appended to the front of the UUID and enables additional flexibility in tracking individual fish and sample numbers. If you enter either Beep or No beep in the Did you detect a CWT in the Chinook? a new question will appear asking what Detection method you used. Also, if you selected Adult female or Sub-adult female for the Sex and maturity question, you will be asked an optional question regarding Spawn condition of the fish. Length measurements are sometimes required when tissue samples are taken for DNA analyses. In our example form you will be asked to enter a fish length if you select either Otolith or Tissue for the Did you take a sample? question. If you enter a length you will also be asked what type of length measurement was taken. As always, both the selection of length types, and the triggers for when this question is asked, can be customized to your individual survey protocols. Go back to Number of Chinook counted and edit your answer to a number greater than one. You will still have the ability to enter a location for where you saw the group of fish. You can also enter Sex and maturity, Adipose clip status, and whether you detected coded-wire tags in the group of fish. If you answer Beep or No Beep to the question Did you detect a CWT in the Chinook you will also be asked about Detection method. However, if you detected a coded-wire tag (CWT) and need to record a CWT head label number you will be required to enter this on an individual basis. You will only have the ability to enter a CWT head label number if the Number of Chinook counted is 1. 2.3.3 Fish redd Click the Done button and cycle back to the top of the subform to enter a new observation. This time select Fish redd as the Observation type and Steelhead as the Species. Once again the first set of questions look similar, but you will now be asked to enter the Number of redds observed. If you enter a count greater than zero, you will also be asked to enter a Redd location. Notice that we have now set the Redd location question to required, as indicated by the asterisk. After you enter the location a hidden field will be generated in the background that will include only the latitude and longitude portions of the location output. For example: 47.065892: -122.887961 This is a good example of how you can pull out just the parts you need from a given data input element and combine those parts in arbitrary ways to generate custom data elements. Details on how to create this input element is included in chapter 3. If you enter a count greater than zero for Number of redds observed you will also be asked about Redd status. The typical options will be listed for selection, but if your protocols require additional categories, those can easily be added. You will also be asked if there were Any live Steelhead associated with the redd?. If you answer Yes you will then have the option to enter the number of Steelhead seen, the Sex and maturity, and the Adipose clip status of the live steelhead. Unlike the restrictions applied to carcass data, there are no requirements to enter data for redds on an individual basis. However, if you wanted to add questions to your form that typically require individual entries, such as redd shape, tailspill height, or substrate type, then you would need to condition those question on Redd count and only show these question if the count was one. 2.4 Additional options The example survey form described above includes most of the basic input elements that would typically be needed for spawning ground surveys. Although the form has intentionally been kept simple to illustrate basic concepts, other data inputs can easily be added. Questions regarding items such as gill condition, egg retention, marks or tags, would be trivial to implement. The relatively simple structure, consisting of one parent form and one subform, is sufficient to incorporate many additional data input elements. You always have the option to add more subforms, but keep in mind that the simpler the structure of the form, the simpler it is build and maintain. It can quickly become challenging to reason about conditional logic when multiple subforms are involved. At that point you may find you need to pass hidden values back and forth between parent and multiple subforms. As a general rule, simpler is nearly always better. Before you add new data input elements to your mobile form please take a look at the spawning_ground database Data Dictionary. This document lists the full range of data elements available to be incorporated into mobile forms. Feel free to contact me if you have any questions. "],
["build-a-form.html", "3 Build a form 3.1 Parent form 3.2 Observations subform", " 3 Build a form The sections below use the Package_spawning_ground.json example form to illustrate how to build a mobile form on the iFormBuilder platform. If you have not done so already, please see the instructions in Chapter 2 to load this package to your profile. Then open the iFormBuilder web interface, click on Forms &gt; Form Builder &gt; spawning_ground_p to load the example form. Chapter 2 provided a high level tour of the example spawning_ground survey form the perspective of the end-user. The focus was on the appearance and behavior of the data input elements that a user would encounter on the mobile device. In Chapter 3 the focus shifts to the iFormBuilder web interface and dives into mobile form construction techniques. Details will be provided on how data input elements can be defined, validated, conditionally hidden, and assigned default values. There will be special emphasis below on the core data inputs that need to be present if data from a mobile form is intended for submission to our corporate spawning ground database. If a core input element is missing it will not be possible to upload any of the data from your mobile form to our central database. 3.1 Parent form The parent form contains data input elements that you would typically only enter once per survey. Fields such as surveyor names, the stream and stream reach you are surveying, or the survey date, are typical parent form data. These are the header fields that you would normally see at the top of a paper form. 3.1.1 Survey ID (core input element) The first input in the parent form of any mobile form used for spawning ground surveys should be a unique survey ID. Although iFormBuilder has a widget titled Unique ID this is not a good choice for our purposes. The iFormBuilder Unique ID widget is merely a combination of a constant prefix and an integer value that increments each time you start filling out a new form. For example, D16-1, D16-2, etc. The reason that iFormBuilderâ€™s solution is not a good choice is that it may result in generating IDs that conflict over time. For example, if after a season of using a form you decide to amend the structure, retire the old form and deploy the new version, you may end up with identical IDs for different surveys unless you also make sure to edit the prefix to some value never previously used. An alternate scenario is that you may want to create dedicated forms for different types of surveys, such as for fall Chinook, or spring Steelhead. To enfore uniqueness statewide there would need to be coordination in assigning prefixes over WDFW districts and regions, otherwise new forms may start incrementing overlapping IDs. An even more important reason for adding a truly unique survey ID input element to our forms is that it can then be used as a primary key in our corporate database. To that end what we need is a unique identifier that is (virtually) guaranteed to always be unique. The solution is to use a random uuid (universally unique ID). A version 4 uuid can be generated using the JavaScript code below. See the following link at Stackoverflow for the source of the function. function generateUUID () { // Public Domain/MIT var d = new Date().getTime(); if (typeof performance !== &#39;undefined&#39; &amp;&amp; typeof performance.now === &#39;function&#39;){ d += performance.now(); //use high-precision timer if available } return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) { var r = (d + Math.random() * 16) % 16 | 0; d = Math.floor(d / 16); return (c === &#39;x&#39; ? r : (r &amp; 0x3 | 0x8)).toString(16); }); } You can copy and paste this function directly into the JavaScript panel of your parent form. To access the JavaScript panel click on the curly braces icon {} in the top right corner of the Forms page when using the online Form Builder application. Make sure you paste the function into the JavaScript panel for your parent form, not the subform. You can then go back to the form builder interface and create a read-only input element in your parent form by clicking on the Read Only widget in the left-hand pane. The name of the input element in the Element Properties pane on the right-hand side should be survey_uuid. Enter Unique survey ID as the label. In the Dynamic Value box in the Element Properties pane on the right-hand side enter the following: generateUUID() Leave the Condition Value set to false. That way it will be invisible to the surveyor. The survey_uuid element will generate a universally unique ID every time a form is initiated that will look something like: 33b78489-7ad3-4482-9455-3988e05bfb28 There are 2122 possible combinations for a randomly generated version 4 uuid. In practical terms this means that if you generate one billion UUIDs every second for approximately 85 years, the probability that two identical UUIDs will be generated is still only about 50%. See article at Wikipedia. 3.1.2 Data source (core input element) Click on the Data source label in the form view on the left-hand side of the form-builder pane. Then examine the Element Properties in the right-hand pane. The data_source element will typically be another read-only field. It can be hard-coded as &quot;wdfw&quot; in the Dynamic Value box of the Smart Control. You can set the Condition Value to false to hide it from view. On the off-chance that your form will be shared with other organizations, you can also change this input element to a select widget. You will then need to create an option list that includes all organizations using the form. Examples of how to create option lists and use select values are provided in the sections below. For now, letâ€™s just assume data_source will be a hidden, read-only data element. 3.1.3 Observers Click on Observers in the form view. Although observers is not a core required input it is highly recommended that you include this multi-select widget. In the example form it has been set to Required in the Attributes section of the Element properties pane. Click on the green Option lists button to see the observers currently listed. A screen will appear that allows you to assign option lists to data input elements. Multi-select widgets allow you to select one or more of the options listed. If more than one is selected the last names (Key Value) will be concatenated together, separated by commas and a space, for example, Smith, Jones, Nelson. 3.1.4 Data submitter The data_submitter input is another hidden field that is not required, but good practice to include. The data_submitter value is auto-generated in the background, and identifies the person who was logged into the mobile device when the the survey Done button was clicked. The data are derived from default meta-data fields provided by iFormBuilder. To create this input you click on the Text widget in the left-hand sidebar and check the Read-Only box in the Attributes section of the Element Properties box on the right-hand side. In the Dynamic Value box of the Smart Control pane, enter: iformbuilder.lastName There are several built-in functions you can use to generate data such a this. See the JavaScript Tips and Tricks section for additional examples of how these built-in functions can be used. To hide this field so it does not clutter up your display when conducting a survey, you can set the Condition Value to false. 3.1.5 Entry method The Data entry real-time or post-survey? field allows for selectively hiding or showing fields depending on the method used to record data in the field; whether on a mobile device, or on paper. There may be occasions where you need to enter data that was originally recorded on paper. In this case, fields for capturing GPS locations, barcodes, or images would be largely irrelevant. The two options are: Real-time or Post-survey. Click on the green Option Lists bar in the Option List box to see how these options are structured. Notice the Sort Order column in the option list. You can use these values to specify a default answer to display. If you enter 0 in the Dynamic Value box the default value will be Real-time, entering 1 would set the default value to Post-survey. If you do not want to set a default value you can enter -1. Setting a dynamic value of -1 is an explicit way to say the value is currently missing. It is good practice to always initialize select, multi-select, or pick-list widgets with either a default value or -1. Another way to set default values is to reference either the option list Label or Key Value instead. You would simply preface the field name with ZCDisplayLabel or ZCDisplayKey. For example, ZCDisplayLabel_species or ZCDisplayLabel_redd_status. In the case of simple lists such as entry_method using Sort Order as a reference is acceptable. There are only two values to remember. For more more complex cases, however, where there are many options, and possibly conditional logic tied to those option values, it is nearly always better to reference the Label or Key Value instead. The reason is that you are then constructing logical statements with actual understandable names rather than just numbers. For example, once your brain gets past the ugly ZCDisplayKey portion, itâ€™s much easier to understand statements such as: if(ZCDisplayKey_species == &quot;coho&quot; &amp;&amp; ZCDisplayKey_redd_status == &quot;new_redd&quot;) {&quot;Yes&quot;} else {&quot;No&quot;} Rather than: if(species == 3 &amp;&amp; redd_status == 0) {&quot;Yes&quot;} else {&quot;No&quot;} Aside from not having to remember the sort_order values in order to understand what is actually being stated, using Key Values or Labels also avoids having to change the statements if you later need to edit the option list and inadvertantly shuffle the sort_order values assigned to each option. 3.1.6 Survey start date (core input element) The survey_start_datetime field is a core input element. There are several methods to add a date or date-time field to your form. The example form shows perhaps the most common method, but see the: JavaScript Tips and Tricks section for alternative methods. Because it is a core field, and it is not hidden, you will need to check Required in the Attributes box of Element Properties. Note also that the Dynamic Value is generated using a JavaScript function: new date() 3.1.7 Survey method (core input element) The survey_method field is another core input element. If you click on the green Option Lists bar the Assign Option Lists window will open and you will see there are only three options listed: Foot, Raft, and Helicopter. Several additional options that you may want to add are listed in the spawning_ground database Data Dictionary mentioned in chapter 2. If you need to add an option, for example Snorkle, close the Assign Option Lists window and click on Option Lists in the top left-hand corner of the form builder application. A window showing all option lists in your profile will open. Scroll down to the SGS-SurveyMethod option list and click on it. This will open a new window where you can view and edit the SGS-SurveyMethod list. Next, click on the green plus sign at the bottom of the Actions column on the far right. A new row will appear, and a new sequential sort_order number will be automatically assigned. You can then enter Snorkle in the Label column, and a lower case snorkle in the Key Value column. The Key Value name should always be in lower case. Underscores should be used for compound names, such as new_redd. Donâ€™t forget to click the Save icon before closing the Option Lists window. Switch back to the form builder view and notice that the default value for survey_method has been set to 0 in the Dynamic Value box. This means that the default value displayed on the device will be Foot. Since most spawning ground surveys tend to be Foot surveys, this setting allows you to quickly skim by this input when entering header data. If you prefer to manually select a survey_method each time, you can set the Dynamic Value to -1 instead. 3.1.8 Stream (core input element) As mentioned in Chapter 2, you must select a stream before any additional fields in your example form become visible. You will then be able to select start and end points for your survey along the selected stream. Only points belonging to the stream you select will be visible. This is an example of a filtered option list. If you click on the green Option List bar for the stream input element and scroll through the option lists on the left-hand side of the pop-up window, you will see an SGS-Streams option list and a SGS-StreamLocations option list. There are 38 options in the SGS-Streams list, and 210 options in the SGS-StreamLocations list. Option lists for streams and locations in your area may end up being longer. Given the number of elements involved you will want the Element Type to be a Pick List. Close this pop-up window and select Option Lists in the upper left-hand corner of the Form Builder page. Scroll down and click on SGS-Streams to see how this option list is defined. One defining feature of option lists is that the Key Values must all be unique. For this reason you do not want to use the stream name as the key value. There can be multiple Boulder Creeks, or Cedar Creeks within any given watershed. Using the Stream Catalog Code (i.e. 17.0213) is also problematic since there are areas in the state where smaller streams may not have been assigned a code. The solution is to use the unique integer ID from the old Spawning Ground Survey (SGS) database for the Key Value. Contact me if you need a list of ID values for streams in your district. 3.1.9 Survey start point (core input element) Every survey must have a start and stop point. Click on Option Lists again in the top-left corner of the form builder and select SGS-StreamLocations to see how these points are defined. The Label lists the river mile of the point, along with a short description: RM 0.00: Mouth. This is the part that will be visible when using the form. The Key Value is a combination of the integer ID of the stream combined with an underscore separator and finally the river mile formatted to three digits before the decimal and two digits after the decimal. This ensures that the Key Value will always be unique and of consistent length. To see how this list is filtered by stream click on the Condition Value button in the upper-left hand corner of the option list window. This will turn the button from gray to green and reveal the Condition Value column in the option list. Setting condition values in option lists follows the same rules as showing or hiding data input elements in a form. You can use the same ZCDisplayKey or ZCDisplayValue terminology as when setting Element properties in the form builder interface. If you want to temporarily hide an option from view, you can also set the Condition Value to false. In the example above, the five options at the top of the SGS-StreamLocations option list will only be visible if the key_value for the stream you selected was 285. The convention for coding Key values for locations that are Not listed above is to concatenate a zero with an underscore and the stream ID. For example: 0_285. This ensures that no duplicate Key Values will be entered to the option list. Option lists such as SGS-StreamLocations, with upwards of 210 elements and 38 different condition values, can be tedious to create by hand. A better option is to create and write such lists directly to the iFormBuilder cloud using scripts. This can be accomplished in seconds using the iformr package for the R programming language. See the package documentation for usage examples. I can also provide example scripts. 3.1.10 Start or end point not listed If the Label of a selected start_point or end_point is Not listed above, then two additional data inputs will appear allowing you to enter the river mile, and optionally, a description of the start or end point. The start_not_listed and end_not_listed inputs are set to Element Type Text. Although setting the Element Type to Number instead of Text may seem more logical, there are a number of reasons why text values tend to be easier to work with, especially if you are going to use the value later in a condition statement, or if you intend to export your data to Excel. Set the Keyboard to Number and Punctuation to allow entry of decimal points. The Dynamic Value should be initiated to {&quot;&quot;} indicating a missing value. To ensure that you only see these inputs in case the start or end points are Not listed above set the Condition Value to ZCDisplayValue_start_point == &quot;Not listed above&quot; or ZCDisplayValue_end_point == &quot;Not listed above&quot; respectively. Also notice that these inputs have been set to Required in the Attributes section of the Element Properties. This is conditional on the inputs being visible. You will only be required to enter a value in these inputs if you selected Not listed above in the start or end point pick lists. Scroll down to the lower portion of the Element Properties pane to see examples of how to code a Client Validation and add a Validation Message. The Client Validation logic should be set up to describe what you expect to see. In this case we want the river mile value to be between 0 and 999. If you enter a value outside this range you will see the Validation Message when you press the Done button. You will not be able to submit your data to the server until you enter a valid number. Notice that we are first converting the start_not_listed value that we entered as text to a number before doing the comparison. This is an example of using the JavaScript function Number() to do a simple conversion. 3.1.11 Start or end point description This input allows you to add a brief text description of the start or end point. In this case we have set the limit to 200 characters. If you anticipate using the Not listed above option frequently, or plan to conduct many exploratory surveys, you may also want to add a Location input, to capture coordinates of the new start and end points, or an Image input to take photos of the reach end points. In this case you would set the Condition Value to ZCDisplayValue_start_point == &quot;Not listed above&quot; for each input. 3.1.12 Water temperature (degrees C) The structure of the water temperature input is very similar to the inputs for manual entry of start and end points. Again, the Element Type has been set to Text, the Keyboard has been set to Number and Punctuation, and the Dynamic Value initiated to an empty character {&quot;&quot;}. The Condition Value has been set to start_point &gt; -1 so that the input will only be displayed after the sampler has entered a value for start_point. The Client Validation setting requires that the start_temperature_c value be within a reasonable range, otherwise the surveyor will see a message warning that The start point water temperature must be between 0 and 38 degrees Celsius when pressing the Done button at the end of the survey. 3.1.13 Target species label This Label input is an example of providing simple text reminders to the surveyor, or to stress something important. No data are recorded here. The input merely displays a message. 3.1.14 Target species The target_species and fish_redd_zeros inputs allow for automating the entry of zero counts. Instead of surveyors having to manually enter counts of zero for each species they were intending to count but did not encounter, the job can be offloaded to a computer. One or more species are selected from an option list then a select input is clicked to determine if the zeros should be added for just fish, redds, or both. The Dynamic Value has been set to 2. This is the sort_order value for Both fish and redds. When the code that parses survey data into the database encounters this value it will automatically assign zero counts for all species selected using this input. Zeros will be assigned for both fish counts and fish redd counts. The Condition Value for the fish_redd_zeros uses a JavaScript function length to determine if any target_species have been selected: ZCDisplayValue_target_species.length &gt; 0. If no target_species are selected the default value will be &quot;&quot;, an empty text string of length zero. If at least one target_species is selected the length will be greater than one. Measuring the length of text strings can often be useful for setting up condition statements. 3.1.15 Dividers Dividers can be useful for breaking up sections of forms into more visually digestible chunks. In our example the dividers highlight the observation_subform input. Note that dividers can be conditionally set to hidden or visible just as with other inputs. Here the dividers will only become visible if at least one target_species has been selected. The aim is to keep the appearance of the form as minimally cluttered as possible. 3.1.16 Observations, yes-no? Directly below the section divider is the observations_yes_no select input. To force surveyors to enter values for target_species this input also remains hidden until at least one target_species is selected. As with the fish_redd_zeros input, the Condition Value has been defined as: ZCDisplayValue_target_species.length &gt; 0. 3.1.17 Observations subform If you answer Yes in the observations_yes_no input the observation_subform input will become visible. Clicking this input will open a new subform where you can enter all observations of fish or redds encountered during the survey. Note that this input includes an entry in the Reference ID 1 box near the bottom of the Element Properties pane. By entering SUBFORM_BATCH_MODE here the behavior of the subform changes. Instead of cycling back to the parent form after every observation, you will be sent back to the top of the subform after every observation. This can speed up data entry by avoiding having to re-open the subform for each observation. See the Reference ID Overview for additional details on this topic. 3.1.18 End of survey, yes-no? This input acts as a trigger to unhide input elements that should only be answered at the end of a survey. Again the Condition Value requires that at least one target_species is entered before this input becomes visible. The default Dynamic Value is set to {1} for No. Note that this select input shares the same SGS-YesNo option list as the observations_yes_no input. Always keep in mind that if you share option lists then any edits you make to those option lists will propogate to all inputs that share the lists. Simple Yes-No option lists are good candidates for sharing. For more complex option list, where there is a possibility you may need to make individual edits, sharing should be avoided. 3.1.19 Survey conditions After answering Yes to the survey_end_yes_no input element a set of inputs asking about general survey conditions, including end water temperature, stream-flow, visibility, and weather, will be revealed. In terms of structure, there is little new that needs to be mentioned. These inputs are all conditional on stream &gt; -1 &amp;&amp; ZCDisplayValue_survey_end_yes_no == &quot;Yes&quot;. Some are optional and others are required. This can be customized depending on your survey protocols. Feel free to add or eliminate questions depending on your specific protocols. You can also look at incorporating legacy Condition Codes as select elements. A list of available canned condition codes can be seen by clicking on the Survey comments table in the Data dictionary for the new spawning_ground database. 3.1.20 Survey completed? Although techically not core input elements the completion_type and linked completion_type_label elements are highly recommended, and should be set to Required. For the completion_type input, the default Dynamic Value has been set to {0}, indicating a Completed survey. If anything else is selected the completion_type_label element will appear and you will be required to enter a reason why the survey was not completed in the Survey comments input. The Condition Value for the completion_type_label element uses a JavaScript if() statement to determine if the label should be set to visible: true, or hidden: false. The complete statement: if(completion_type == 0) {false} else {true} can be a handy example to keep in mind for conditionally setting the visibility of inputs. 3.1.21 Survey comments The survey_comment input is normally optional, and allows for entering general comments. Note, however, that if you select anything other than Completed survey in the completion_type input, then survey_comment becomes a required field. Three steps are required to accomplish this. First enter if(completion_type &gt; 0) {&quot;Survey comments (required)&quot;} else {&quot;Survey comments (optional)&quot;} into the Dynamic Label box. Next use another if statement in the Client Validation box. Enter: if(completion_type &gt; 0) {survey_comment.length &gt; 0} else {survey_comment.length &gt; - 1}. Finally enter a message to display to the surveyor if the condition is not met. In this case the message is: &quot;Please explain why the survey was not completed&quot;. Translated into words the Client Validation code states that if the survey was not completed then there must be a comment entered into the survey_comment input that has a string length greater than 0. Otherwise the length of your survey_comment string can be either zero or greater. If those conditions are not met you will see the Validation Message when you try to press the done button. You will not be able to save the survey as anything other than a draft until you add a survey_comment. 3.1.22 Survey end time The final Date-Time input allows you to enter the time the survey was completed. Although not required, this can be useful for planning purposes and for tracking how long it typically takes to complete a survey along a specific stream reach. Again, you will only see this input unless you have seleced a stream and entered Yes to the survey_end_yes_no question. 3.2 Observations subform The observations subform contains data input elements that you would normally cycle back to multiple times during a survey. Fields such as counts of fish, or redds, that you encounter as you walk the reach are typical observation subform data. If you are sampling fish, taking measurements, scale samples, or tissue samples for DNA analysis, these would be entered as separate lines of data in the subform; one line per fish. Simple counts of fish may be entered as lump counts in many cases. As you work your way downstream counting fish you will normally want to enter those counts repeatedly, with each count categorized by factors such as species, whether they are alive or dead, adipose clip status, sex, or maturity. 3.2.1 Entry method text The entry_method_text input is a hidden text field intended only to pass the Key Value from the parent form entry_method select widget down to the observation subform. The possible values are: realtime or postsurvey. These values are used to hide or unhide data elements further down in the form based on whether the form was filled out real-time, during a survey, or entered from notes post-survey. If data were entered post-survey we would probably not need to show GPS or barcode inputs, or inputs for taking pictures. These can all be hidden if the Key Value for entry_method is set to postsurvey. 3.2.2 Observation type The observation_type single-select element is another gatekeeper element that conditionally filters data input elements based on your selection. The three options are: Live fish, Carcass, and Fish redd. For example, if you are counting live fish you would select the Live fish option, then only inputs relevant to live fish will be displayed. You will not see inputs for redd counts, or GPS locations for carcasses. Note the coding for the Dynamic Value. This is a bit convoluted to understand at first glance, and provides a taste of why keeping your forms as simple as possible is a good thing. spawning_ground_p.observation_subform[spawning_ground_p.observation_subform.index - 1].observation_type The aim of this code is to produce the stickiness behavior referred to in section 2.3.1. Assume you are conducting a winter Chum survey. You will not want to manually select Species, Run year and Survey type each time the subform cycles back to a new count. These values are unlikely to change from one observation to the next. Instead you will want these inputs to be auto-filled based on what you entered most recently. The Dynamic Value code looks into the subform records for the last entered value, then sets this as the default. Cumulatively this can avoid a large number of unnecessary clicks over the course of a survey, and considerable speed up data entry in the field. Breaking this code down into separate chunks may help clarify what is going on. In JavaScript and many other programming languages square brackets are often used to index data. For example to pull out the first element of an array of fish such as: var species = [&quot;Coho&quot;, &quot;Chinook&quot;, &quot;Chum&quot;], you would write species[0]. You use 0 instead of the more intuitive 1 because JavaScript begins all indexing at 0. The result would be &quot;Coho&quot;. Indexing can also be used to inspect values in your forms. The first part of the Dynamic Value code: spawning_ground_p.observation_subform specifies that the data you need is in the observation_subform of the spawning_ground_p parent form. Note that observation_subform is the data column name we gave to our subform in the parent form. The second part, inside the brackets, specifies the index or row where the data you need is stored: [spawning_ground_p.observation_subform.index - 1]. The .index portion of the code tells you what row you are currently working on. If you subtract 1 you get the index value of the last row of data you saved. So to summarize, the first part specifies what form to look in. The second part specifies what row to look in, and the final part, .observation_type specifies the data element you want to extract a value from. The relative complexity of the Dynamic Value code for observation_type should serve as a warning for why nesting one subform inside another subforms is generally a bad idea. There are many cases where you want to pass values between forms, or from previously entered rows. Each time you nest a subform you get an exponential increase in the verbosity and complexity of code such as this. Additional information on passing values between forms or subforms can be found in the following JavaScript Tips &amp; Tricks article. 3.2.3 Species (core input element) The species_text input is a hidden element that pulls out the Label portion of the species_fish option list. For example, the first two elements of the SGS-Species option list are Chinook and Chum. The species_text values come in handy for dynamically changing the labels you see in the subseqent input elements. See the Survey type input for an example. Here the Dynamic Label is coded as: &quot;Please enter the survey type for &quot; + species_text. If species text was Chinook, the label would read: Please enter the survey type for Chinook. The species_fish input is a Pick list widget due the large number of options. The Dynamic Value is coded using the same logic as for observation_type to make it sticky. Note also that species_fish is included in the Condition Value statements of a majority of the remaining inputs in the observation subform. You will need to enter a species before these remaining inputs become visible. 3.2.4 Run year (core input element) Run year is another core element. In the example form the Dynamic Value has been coded using a JavaScript function to pull out just the year portion of the current date: new Date().getFullYear(). This will generate a four character text value of the current year. You can edit this value. It just serves as a starting point. Most of the time it will not need to be edited, but the option is available when needed. 3.2.5 Survey type (core input element) Survey type is also a core input element. In the example form it has been coded as a select input with four options. See the Data dictionary for the new spawning_ground database if any option that you need are missing. The structure of this input is the same as many others. No additional comments are needed. The only new item is that we have added a Label input directly below that describes each option in more detail. This type of input can be handy when you need to include explicit documentation for specific inputs. 3.2.6 Redd count The redd_count input is another Text input with a Number pad data entry keyboard. The Condition Value is defined so that it will only appear if a species_fish is selected and the observation_type Key Value is fish_redd. In the Element Properties it is set as Required. For all practical purposes it will only be required if the observation_type is fish_redd. Input elements are truly required until they are visible. 3.2.7 Redd location The coding for redd_location is a bit more complex than other inputs. It is set as Required in the example form but your survey protocols may differ. The Dynamic Value is set to an empty string {&quot;&quot;}. This is needed to make sure you do not recycle previously used GPS locations. An unfortunate side-effect of the Location widget is that it can be sticky without any help on your part. The Condition Value for redd_location is where the complexity enters. We want to hide the input if the Label for observation_type is either Live fish or Carcass. And we only want to show the input if we have counted one or more actual redds and the entry_method is realtime. The full code is: if(ZCDisplayValue_observation_type == &quot;Live fish&quot; || ZCDisplayValue_observation_type == &quot;Carcass&quot;) {false} else {Number(redd_count) &gt; 0 &amp;&amp; entry_method_text == &quot;realtime&quot;} To make the code more readable we are using the Labels from the observation_type rather than the sort_order values. Getting used to writing conditional statements like this can take some practice. The logic is not always intuitive. Here we needed to explicitly define the false portion first, and only then define the true portion. 3.2.8 Redd coordinates This element is only included to pull out the latitude: longitude coordinates and combine them into a single text string. This can make it easier to work with the data later. Otherwise what iFormBuilder outputs is a long unwieldy list of values. The code: redd_location.latitude + &quot;: &quot; + redd_location.longitude produces a string that looks like: 47.50436: -123.49568. 3.2.9 To be continued in September. "],
["summary.html", "4 Summary 4.1 ToDo 4.2 Notes on bookdown", " 4 Summary 4.1 ToDo Finish iformr packageâ€¦Done Finish spawning ground formâ€¦Done Discuss subform batch modeâ€¦Done Demonstrate how to download data? Write up steps to create and activate branch in remoteâ€¦Done 4.2 Notes on bookdown 4.2.1 Files needed to build basic book: .gitignore .Rbuildignore Index and 01-0n.Rmd files _build.sh (enables the build all command) book.bib 4.2.2 Building these files generates: book.bib _book (folder) .html files (generated from Index and 01-0n.Rmd files) search_index.json libs (folder) gitbook-2.6.7 (folder) jquery-2.2.3 (folder) "],
["appendix.html", "5 Appendix 5.1 JavaScript functions 5.2 Character limits 5.3 Maximum inputs per form", " 5 Appendix 5.1 JavaScript functions You can copy and paste these functions directly into the JavaScript panel of your parent form. To access the JavaScript panel click on the curly braces icon {} in the top right corner of the Forms page when using the online Form Builder application. 5.1.1 Unique ID (UUID) From Stackoverflow. function generateUUID () { // Public Domain/MIT var d = new Date().getTime(); if (typeof performance !== &#39;undefined&#39; &amp;&amp; typeof performance.now === &#39;function&#39;){ d += performance.now(); //use high-precision timer if available } return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) { var r = (d + Math.random() * 16) % 16 | 0; d = Math.floor(d / 16); return (c === &#39;x&#39; ? r : (r &amp; 0x3 | 0x8)).toString(16); }); } 5.1.2 Statistical week. For WDFW the standard statistical week starts on Monday and ends on Sunday. The first day of the year is always in week 1. This function generates the statistical week from a date value. To use in a mobile form create a new text input element below your survey_start_datetime data element. Then in the Dynamic Value box of the new input enter: survey_start_datetime.fishStatWeek(). Date.prototype.fishStatWeek = function () { var jan_one = new Date(this.getFullYear(), 0, 1); var week_day = jan_one.getDay(); var adj_day = -1; if (week_day === 0) adj_day = 0; var n_days = ((this - jan_one) / 86400000) + 1; return Math.ceil((n_days + week_day - 1) / 7) + adj_day + 1; }; 5.1.3 Pad a number Pad a number with three leading zeros. For example, change 01 to 0001, or 2 to 0002. Author: Jake Shapely. function pad(num) { var s = num + &quot;&quot;; while (s.length &lt; 3) s = &quot;0&quot; + s; return s; }; 5.2 Character limits The iFormBuilder platform imposes limits on the number of characters that are allow for naming or defining various items. The following table was compiled from disparate parts of the iFormBuilder website by Steve VanderPloeg. IForm character limits: Form Name Label: 500 Form Name: 50 Field Name Label: 1000 Field Name: 65 Conditional Values: 500 Dynamic Values: 500 Dynamic Labels: 500 Client Validation: 500 Validation Labels: 500 Data column name: 65 Text-area widget: 65,000 5.3 Maximum inputs per form The iFormBuilder website recommends limiting the number of inputs in a form or subform to 100. If your needs exceed 100 inputs for any given form, they recommend breaking up those forms into one or more subforms. As mobile devices have become more powerful those recommended limits have increased from 35-40 inputs to the most recent recommendation of 100 inputs (as of 2016). This is only a guideline, and given the increasing power of newer devices, these recommendations may already be out of date. The highly opinionated counter-recommendation in this manual is to try and keep your forms as simple as possible by minimizing the number of subforms whenever possible. Then test thoroughly to ensure your forms stay responsive. Instead of setting an arbitary limit on the number of inputs per form, a better policy is to carefully test for performance issues. Depending on the type of inputs, you may be able to exceed the 100 input recommendation by a considerable margin. Only break up forms into subforms if performance starts to deteriorate markedly. To streamline data entry you should instead be vigilant in hiding inputs whenever possible. A few judiciously placed questions in tandem with condition statements can often serve to hide all but the few relevant inputs needed for any given observation. For field use, speed of data entry is often the most important consideration. Switching between subforms slows down the process. Ideally you would have just one parent form for header data and one primary subform for the majority of your repeat observations. "],
["references.html", "References", " References "]
]
